I"]%<h2 id="network-reconstruction">Network reconstruction</h2>

<p>The purpose of this part:</p>

<p><strong>create a gene regulatory network from transcriptome dataset</strong>.</p>

<p>No “lazy mode” function available for this part. The most important function here is : <code class="highlighter-rouge">SJAracne.prepare()</code>, user could directly call this function if eset (an ExpressionSet class object), TF_list (list of transcription factor genes with ID match the main ID type in eset) and SIG_list (list of signaling factor genes with ID match the main ID type in eset) are well prepared. Others are mainly supporting functions for eset QC, ID conversion and etc.</p>

<p>The complete step-by-step demo script for network reconstruction can be found here, <a href="https://github.com/jyyulab/NetBID-dev/blob/master/demo_scripts/pipeline_network_demo1.R">pipeline_network_demo1.R</a>.</p>

<hr />
<h2 id="quick-navigation-for-this-page">Quick Navigation for this page</h2>

<ul>
  <li><a href="#step-0-preparations">Step 0: Preparations</a></li>
  <li><a href="#step-1-load-in-gene-expression-datasets-for-network-reconstruction-exp-load">Step 1: Load in gene expression datasets for network reconstruction (exp-load)</a>
    <ul>
      <li><a href="#the-choice-of-expression-data-set-for-network-reconstruction">Q&amp;A: The choice of expression dataset for network reconstruction</a></li>
      <li><a href="#input-rna-seq-dataset">Q&amp;A: Input RNA-Seq dataset</a></li>
      <li><a href="#input-expression-matrix-not-from-geo-database">Q&amp;A: Input expression matrix not from GEO database</a></li>
    </ul>
  </li>
  <li><a href="#step-2-normalization-for-the-expression-dataset-exp-qc">Step 2: Normalization for the expression dataset (exp-QC)</a>
    <ul>
      <li><a href="#qc-for-rna-seq-dataset">Q&amp;A: QC for RNA-Seq dataset</a></li>
      <li><a href="#combine-two-datasets">Q&amp;A: Combine two datasets</a></li>
    </ul>
  </li>
  <li><a href="#step-3-check-sample-cluster-analysis-optional-exp-cluster">Step 3: Check sample cluster information, optional (exp-cluster)</a></li>
  <li><a href="#step-4-prepare-files-to-run-sjaracne-sjaracne-prep">Step 4: Prepare files to run SJARACNe (sjaracne-prep)</a>
    <ul>
      <li><a href="#id-conversion">Q&amp;A: ID conversion</a></li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="step-0-preparations">Step 0: Preparations</h2>
<p><strong>Purpose: create an organized working directory for the network reconstruction step in NetBID2 analysis.</strong></p>

<p>Make sure you have NetBID2 package.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">NetBID2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Create directories and folders to save and organize your analysis results.</p>

<p>We have designed a function <code class="highlighter-rouge">NetBID.network.dir.create()</code> to handle the working directories, so users can have a better data organization.
This function needs users to define the main working directory <code class="highlighter-rouge">project_main_dir</code> and the project’s name <code class="highlighter-rouge">project_name</code>. 
To prevent previous project with the same <code class="highlighter-rouge">project_main_dir</code> and <code class="highlighter-rouge">project_name</code> from being rewrite, it is highly suggested to add a time tag to your <code class="highlighter-rouge">project_name</code>.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Define main working directory and project name</span><span class="w">
</span><span class="n">project_main_dir</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s1">'./test'</span><span class="w"> </span><span class="c1"># user defined main directory for the project, one main directory could have multiple project folders, distinguished by project name.</span><span class="w">
</span><span class="n">current_date</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">format</span><span class="p">(</span><span class="n">Sys.time</span><span class="p">(),</span><span class="w"> </span><span class="s2">"%Y-%m-%d"</span><span class="p">)</span><span class="w"> </span><span class="c1"># optional, if user like to add current date to name the project folder</span><span class="w">
</span><span class="n">project_name</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sprintf</span><span class="p">(</span><span class="s1">'project_%s'</span><span class="p">,</span><span class="n">current_date</span><span class="p">)</span><span class="w"> </span><span class="c1"># project name for the project folders under main directory.</span><span class="w">
</span></code></pre></div></div>

<p><code class="highlighter-rouge">NetBID.network.dir.create()</code> creates a main working directory with a subdirectory of the project. 
It also automatically creates three subfolders (QC, DATA and SJAR) within the project folder. 
QC/, storing Quality Control related plots; DATA/, saving data in RData format; SJAR/, storing files needed for running SJAracne <a href="https://github.com/jyyulab/SJARACNe">SJARACNe</a>. 
It also returns a list object, here named <code class="highlighter-rouge">network.par</code> with directory information wrapped inside. 
This list is an ESSENTIAL varaible for network reconstruction, all the important intermediate data generated later on will be wrapped inside.
If the current environment already has this variable, the function will only report a warning message and return the existed <code class="highlighter-rouge">network.par</code>.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create a hierarchcial working directory and return a list contains the hierarchcial working directory information</span><span class="w">
</span><span class="c1"># This list object (network.par) is an ESSENTIAL variable in network reconstruction pipeline</span><span class="w">
</span><span class="n">network.par</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">NetBID.network.dir.create</span><span class="p">(</span><span class="n">project_main_dir</span><span class="o">=</span><span class="n">project_main_dir</span><span class="p">,</span><span class="n">project_name</span><span class="o">=</span><span class="n">project_name</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h2 id="step-1-load-in-gene-expression-datasets-for-network-reconstruction-exp-load">Step 1: Load in gene expression datasets for network reconstruction (exp-load)</h2>
<p><strong>Purpose: download the target expression profile and perform quality control analysis on the raw data.</strong></p>

<p>Here, we use <code class="highlighter-rouge">GSE116028</code> microarray data from GEO as the demo dataset. (Check <a href="#the-choice-of-expression-data-set-for-network-reconstruction"><strong><em>The choice of expression dataset for network reconstruction</em></strong></a> for more details). 
Given the ID of GSE (GEO series) and GPL (GEO platform), <code class="highlighter-rouge">load.exp.GEO()</code> will download the corresponding expression dataset from GEO database.
The data will be saved as <a href="https://www.rdocumentation.org/packages/Biobase/versions/2.32.0/topics/ExpressionSet">eSet</a> class object in the environment, and will also be saved as RData in the <code class="highlighter-rouge">out.dir</code> folder.
To download gene annotation file, one need to set <code class="highlighter-rouge">getGPL=TRUE</code>. 
To prevent repetitive download instead of updating, one need to set <code class="highlighter-rouge">update=FALSE</code>, so <code class="highlighter-rouge">load.exp.GEO()</code> will reload the existed RData (in this demo, RData will be reload from <code class="highlighter-rouge">DATA/GSE116028_GPL6480.RData</code>) directly.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Download expression dataset from GEO, need to provide GSE ID and GPL ID</span><span class="w">
</span><span class="n">net_eset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">load.exp.GEO</span><span class="p">(</span><span class="n">out.dir</span><span class="o">=</span><span class="n">network.par</span><span class="o">$</span><span class="n">out.dir.DATA</span><span class="p">,</span><span class="n">GSE</span><span class="o">=</span><span class="s1">'GSE116028'</span><span class="p">,</span><span class="n">GPL</span><span class="o">=</span><span class="s1">'GPL6480'</span><span class="p">,</span><span class="n">getGPL</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="n">update</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><em>Optional:</em>
Directly looking at the probe expression value from the raw expression dataset is not much meaningful.
<code class="highlighter-rouge">update_eset.feature()</code> allows users to reassign the featureData slot of ExpressionSet object based on user’s demand. For example, from probe IDs to gene IDs.
Given the conversion table <code class="highlighter-rouge">use_feature_info</code>, <code class="highlighter-rouge">from_feature</code> and <code class="highlighter-rouge">to_feature</code>, this function will convert old IDs into new IDs using <code class="highlighter-rouge">merge_method</code>.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ID conversion, or merge transcript level to expression level, use_feature_info can be other dataframe instead of fData; optional;</span><span class="w">
</span><span class="n">net_eset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">update_eset.feature</span><span class="p">(</span><span class="n">use_eset</span><span class="o">=</span><span class="n">net_eset</span><span class="p">,</span><span class="n">use_feature_info</span><span class="o">=</span><span class="n">fData</span><span class="p">(</span><span class="n">net_eset</span><span class="p">),</span><span class="n">from_feature</span><span class="o">=</span><span class="s1">'ID'</span><span class="p">,</span><span class="n">to_feature</span><span class="o">=</span><span class="s1">'GENE_SYMBOL'</span><span class="p">,</span><span class="n">merge_method</span><span class="o">=</span><span class="s1">'median'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><em>Optional:</em>
Users can use <code class="highlighter-rouge">update_eset.phenotype()</code> to extract interested phenotype information from phenoData slot of ExpressionSet object, and update it.
Use <code class="highlighter-rouge">use_col</code> to tell the function which column(s) in <code class="highlighter-rouge">use_phenotype_info</code> to keep. If set to <code class="highlighter-rouge">auto</code>, it only extracting “cluster-meaningful” sample features (e.g. it is meaningless to use “gender”” as clustering feature, if all samples are female).
If set to <code class="highlighter-rouge">GEO-auto</code>, it will extract columns: “geo_accession””, “title”, “source_name_ch1” and columns names ended with “:ch1”.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Select phenotype columns or user added phenotype info; optional</span><span class="w">
</span><span class="n">net_eset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">update_eset.phenotype</span><span class="p">(</span><span class="n">use_eset</span><span class="o">=</span><span class="n">net_eset</span><span class="p">,</span><span class="n">use_phenotype_info</span><span class="o">=</span><span class="n">pData</span><span class="p">(</span><span class="n">net_eset</span><span class="p">),</span><span class="n">use_sample_col</span><span class="o">=</span><span class="s1">'geo_accession'</span><span class="p">,</span><span class="n">use_col</span><span class="o">=</span><span class="s1">'GEO-auto'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>Now, wrap this ExpressionSet object <code class="highlighter-rouge">net_eset</code> into the ESSENTIAL variable <code class="highlighter-rouge">network.par</code>.</strong></p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Add the variable into network.par. ESSENTIAL STEP.</span><span class="w">
</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">net_eset</span><span class="w">
</span></code></pre></div></div>

<p><strong>Perform quality control for the raw ExpressionSet object.</strong>
Call <code class="highlighter-rouge">draw.eset.QC()</code>, an HTML report containing quality control analysis plots will be created. 
Users can choose interested phenotype information from phenoData slot to do this quality control, by assigning value to <code class="highlighter-rouge">intgroup</code>. 
If <code class="highlighter-rouge">intgroup</code> is NULL, all the columns from phenoData slot will be used.
The HTML created by <code class="highlighter-rouge">draw.eset.QC()</code> is using pandoc. Please make sure you have it installed.
Checking the availability of pandoc, one can call <code class="highlighter-rouge">pandoc_available()</code>.
Installing and setting the environment for pandoc, one can call <code class="highlighter-rouge">Sys.setenv(RSTUDIO_PANDOC=$installed_path)</code>, here replace <code class="highlighter-rouge">$installed_path</code> with the installed path of pandoc. If pandoc not available, users could set <code class="highlighter-rouge">generate_html=FALSE</code> and plots in pdf format will be generated.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># QC for the raw eset</span><span class="w">
</span><span class="n">draw.eset.QC</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">,</span><span class="n">outdir</span><span class="o">=</span><span class="n">network.par</span><span class="o">$</span><span class="n">out.dir.QC</span><span class="p">,</span><span class="n">intgroup</span><span class="o">=</span><span class="kc">NULL</span><span class="p">,</span><span class="n">do.logtransform</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="s1">'beforeQC_'</span><span class="p">,</span><span class="w">
             </span><span class="n">pre_define</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s1">'WNT'</span><span class="o">=</span><span class="s1">'blue'</span><span class="p">,</span><span class="s1">'SHH'</span><span class="o">=</span><span class="s1">'red'</span><span class="p">,</span><span class="s1">'G4'</span><span class="o">=</span><span class="s1">'green'</span><span class="p">),</span><span class="n">emb_plot_type</span><span class="o">=</span><span class="s1">'2D.interactive'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>- What information can you get from the HTML QC report?</strong>  (<a href="beforeQC_QC.html">before_QC.html</a>)</p>
<ul>
  <li>A table. It contains phenotype information of samples. Descriptive variables, such as number of samples and genes (probes/transcripts/…);</li>
  <li>A heatmap and a PCA/MDS/UMAP biplot. All samples will be clustered using the raw expression values across all the genes as features. The aim of this is to check possible mis-labeled samples and the occurrence of batch effects;</li>
  <li>A correlation plot for all sample pairs. This helps to check the correlation within group and between groups.</li>
  <li>A density plot. It shows the range and the distribution of the expression values. This also helps to judge if the original dataset has been log transformed;</li>
</ul>

<p>Now, the basic pre-processing steps are done for the raw data. 
For persistent storage of data, and prevent the re-run of all previous steps. Users can checkout and save <code class="highlighter-rouge">network.par</code> as RData for this part.
The function <code class="highlighter-rouge">NetBID.saveRData()</code> provide easier pipeline step checkout and reference. 
Giving pipeline step name to <code class="highlighter-rouge">step</code>, the <code class="highlighter-rouge">network.par</code> will be saved with step name as <code class="highlighter-rouge">network.par$out.dir.DATA/network.par.Step.{exp-load}.RData</code>.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Save Step 1 network.par as RData</span><span class="w">
</span><span class="n">NetBID.saveRData</span><span class="p">(</span><span class="n">network.par</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">network.par</span><span class="p">,</span><span class="n">step</span><span class="o">=</span><span class="s1">'exp-load'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<hr />
<h3 id="the-choice-of-expression-data-set-for-network-reconstruction"><em>The choice of expression data set for network reconstruction</em></h3>

<ul>
  <li>
    <p>For a NetBID2 project, users need to decide what expression dataset to use for starting their biological story.
Here are some important factors need to be considered, when using the expression dataset to construct regulatory network.</p>

    <ul>
      <li>The reasoning of using expression dataset to infer gene regulatory network is based on <a href="https://academic.oup.com/bioinformatics/advance-article/doi/10.1093/bioinformatics/bty907/5156064">SJARACNe</a>. 
 It uses the information-theoretic approach to eliminate the majority of indirect interactions inferred by co-expression methods. The more samples, the higher sensitivity and precision.
 Typically, more than 100 samples is recommended.</li>
      <li>Large size public datasets from the same tissue, cell line or biological background are recommended to use as the expression datasets. Users can search through public databases, such as <a href="#the-choice-of-expression-dataset-for-network-reconstruction">GEO</a> and <a href="#https://portal.gdc.cancer.gov">TCGA</a>.</li>
      <li>Computationally inferred networks cannot avoid to have false positive edges. Especially for edges with relatively low mutual information (MI) scores. Functional interpretation from the regulatory network will be explained in the <a href="../docs/driver_inference">Driver inference</a> part.</li>
    </ul>
  </li>
  <li>
    <p>In real-world practice, the demo’s expression dataset is too small to construct a high quality network. However, it provides a handy visualization for the procedure of the NetBID2.</p>
  </li>
</ul>

<hr />

<h3 id="input-rna-seq-dataset"><em>Input RNA-Seq dataset</em></h3>

<ul>
  <li>
    <p>NetBID2 provides two functions to load expression dataset from RNA-Seq, <code class="highlighter-rouge">load.exp.RNASeq.demo()</code> and <code class="highlighter-rouge">load.exp.RNASeq.demoSalmon()</code>. 
<strong>BUT</strong> these two function are still in demo version, and don’t support the complicated options in <code class="highlighter-rouge">tximport()</code> and <code class="highlighter-rouge">DESeq()</code>. 
It’s challenging due to the various output format from RNA-Seq (e.g. using different reference genomes). We suggest to use those well-developped tools in this case.</p>
  </li>
  <li>
    <p>If users like to try <code class="highlighter-rouge">load.exp.RNASeq.demo()</code> and <code class="highlighter-rouge">load.exp.RNASeq.demoSalmon()</code>, be aware to the <code class="highlighter-rouge">return_type</code> in these functions.</p>
    <ul>
      <li>‘txi’ is the output of <code class="highlighter-rouge">tximport()</code>. It is a list containing three matrices, abundance, counts and length. “counts” is the matrix of raw count.</li>
      <li>‘counts’ is the matrix of raw count.</li>
      <li>‘tpm’ is the raw tpm.</li>
      <li>‘fpm’, ‘cpm’ is the fragments/counts per million mapped fragments.</li>
      <li>‘raw-dds’ is the DESeqDataSet class object, which is the original one without processing.</li>
      <li>‘dds’ is the DESeqDataSet class object, which is processed by <code class="highlighter-rouge">DESeq()</code>.</li>
      <li>‘eset’ is the ExpressionSet class object, which is processed by <code class="highlighter-rouge">DESeq()</code> and <code class="highlighter-rouge">vst()</code>.</li>
    </ul>

    <p>Default is ‘tpm’. If users don’t choose ‘eset’ as return type. The output object cannot be directly used in the rest pipeline so far. 
  Please check the <strong><em>Input expression matrix not from GEO database</em></strong> section to see how to proceed.</p>
  </li>
</ul>

<hr />
<h3 id="input-expression-matrix-not-from-geo-database"><em>Input expression matrix not from GEO database</em></h3>
<ul>
  <li>If users have expression matrix not obtained from GEO database. They still can prepared the ExpressionSet class object using <code class="highlighter-rouge">generate.eset()</code>.</li>
</ul>

<p>For example, RNA-Seq dataset processed into TPM (transcripts per million).</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#tpm &lt;- load.exp.RNASeq.demo(XXX)</span><span class="w">
</span><span class="n">tmp_mat</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">log2</span><span class="p">(</span><span class="n">tpm</span><span class="p">)</span><span class="w">
</span><span class="n">tmp_eset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">generate.eset</span><span class="p">(</span><span class="n">exp_mat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp_mat</span><span class="p">,</span><span class="w"> </span><span class="n">phenotype_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="n">feature_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">annotation_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">""</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Some details of <code class="highlighter-rouge">generate.eset()</code>:
it generates ExpressionSet class object to contain and describe the high-throughput assays;
Users can define its slots, which are expression matrix (required), phenotype information and feature information (optional);
If <code class="highlighter-rouge">phenotype_info = NULL</code>, a column named with ‘group’ will be automatically generated;
If <code class="highlighter-rouge">feature_info = NULL</code>, a column named with ‘gene’ will be automatically generated.</p>

<hr />

<h2 id="step-2-normalization-for-the-expression-dataset-exp-qc">Step 2: Normalization for the expression dataset (exp-QC)</h2>
<p><strong>Purpose: normalize the expression data and perform quality control analysis on the normalized data.</strong></p>

<p>Please skip the following line if you didn’t close R session after completed Step 1.</p>

<p>Don’t skip, if you have checked out and closed R session after completed the Step 1. Before start Step 2, please reload <code class="highlighter-rouge">network.par</code> RData from Step 1.
<code class="highlighter-rouge">NetBID.loadRData()</code> reloads RData saved by <code class="highlighter-rouge">NetBID.saveRData()</code>. It prevents user from repeating former pipeline steps.
If the re-opened R session doesn’t have <code class="highlighter-rouge">network.par</code> in the environment, please comment off the first two command lines. It will create a temporary <code class="highlighter-rouge">network.par</code>
with path of the saved Step 1 RData, <code class="highlighter-rouge">network.par$out.dir.DATA</code>. The path <code class="highlighter-rouge">test//project_2019-05-02//DATA/</code> here is just an example, 
users need to give their own path used to save <code class="highlighter-rouge">network.par</code> RData from Step 1.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Reload network.par RData from Step 1</span><span class="w">
</span><span class="c1">#network.par &lt;- list()</span><span class="w">
</span><span class="c1">#network.par$out.dir.DATA &lt;- 'test//project_2019-05-02//DATA/'</span><span class="w">
</span><span class="n">NetBID.loadRData</span><span class="p">(</span><span class="n">network.par</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">network.par</span><span class="p">,</span><span class="n">step</span><span class="o">=</span><span class="s1">'exp-load'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The following QC steps are highly suggested for <strong>microarray</strong> dataset, but not essential.</p>

<p><strong>First, the handling of missing data.</strong></p>

<p>Count the number of <code class="highlighter-rouge">NA</code> values for each sample and each gene (or probes/transcripts/…). 
If one sample or gene has too many <code class="highlighter-rouge">NA</code> values, user can choose to remove that sample or gene, or perform imputation by using <code class="highlighter-rouge">impute.knn()</code>.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Get the expression matrix from ExpressionSet object</span><span class="w">
</span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">exprs</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">)</span><span class="w">
</span><span class="c1"># Count and show number of NAs across samples and genes</span><span class="w">
</span><span class="n">sample_na_count</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">){</span><span class="nf">length</span><span class="p">(</span><span class="n">which</span><span class="p">(</span><span class="nf">is.na</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="kc">TRUE</span><span class="p">))})</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">table</span><span class="p">(</span><span class="n">sample_na_count</span><span class="p">))</span><span class="w">
</span><span class="n">gene_na_count</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">){</span><span class="nf">length</span><span class="p">(</span><span class="n">which</span><span class="p">(</span><span class="nf">is.na</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="kc">TRUE</span><span class="p">))})</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">table</span><span class="p">(</span><span class="n">gene_na_count</span><span class="p">))</span><span class="w">
</span><span class="c1"># Perform imputation</span><span class="w">
</span><span class="k">if</span><span class="p">(</span><span class="nf">sum</span><span class="p">(</span><span class="n">sample_na_count</span><span class="p">)</span><span class="o">+</span><span class="nf">sum</span><span class="p">(</span><span class="n">gene_na_count</span><span class="p">)</span><span class="o">&gt;</span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">impute.knn</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="o">$</span><span class="n">data</span><span class="w">
</span></code></pre></div></div>

<p><strong>Second, the log2 transformation.</strong></p>

<p>Sometimes it is hard to know whether the raw dataset has been log2-transformed or not. 
Here, we use a threshold from experience to check the median value. It may not be suitable for all cases, users can modify the threshold based on their own experience.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Perform log2 transformation</span><span class="w">
</span><span class="n">med_val</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">median</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="n">median</span><span class="p">));</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="n">med_val</span><span class="p">)</span><span class="w">
</span><span class="k">if</span><span class="p">(</span><span class="n">med_val</span><span class="o">&gt;</span><span class="m">16</span><span class="p">){</span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">log2</span><span class="p">(</span><span class="n">mat</span><span class="p">)}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Third, the quantile normalization across samples.</strong></p>

<p>This is suggested for dealing with microarray dataset, but not for RNA-Seq or log2tpm etc.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Perform limma quantile normalization</span><span class="w">
</span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">normalizeQuantiles</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="w"> 
</span></code></pre></div></div>

<p><strong>Fourth, filter out genes with very low expression values (bottom 5%) in most samples (more than 90%).</strong></p>

<p>The presence of low-expression genes are less informative for network reconstruction.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Filter out low-expression genes</span><span class="w">
</span><span class="n">choose1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="n">mat</span><span class="o">&lt;=</span><span class="w"> </span><span class="n">quantile</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="w"> </span><span class="n">probs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.05</span><span class="p">),</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="o">&lt;=</span><span class="w"> </span><span class="n">ncol</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.90</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">table</span><span class="p">(</span><span class="n">choose1</span><span class="p">))</span><span class="w">
</span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mat</span><span class="p">[</span><span class="n">choose1</span><span class="p">,]</span><span class="w">
</span></code></pre></div></div>

<p>Now, the expression matrix has been updated. Users need to wrap it into the ExpressionSet class object, so it can be used for later pipeline studies.
<code class="highlighter-rouge">generate.eset()</code> is designed to create the ExpressionSet object when only expression matrix is available.
Users can also update the <code class="highlighter-rouge">network.par$net.eset</code>, and generate the HTML QC report to the normalized data, and save it as RData.
Please use <code class="highlighter-rouge">draw.eset.QC()</code> to create QC report and <code class="highlighter-rouge">NetBID.saveRData()</code> to save the normalized <code class="highlighter-rouge">network.par</code>.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Update eset with normalized expression matrix</span><span class="w">
</span><span class="n">net_eset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">generate.eset</span><span class="p">(</span><span class="n">exp_mat</span><span class="o">=</span><span class="n">mat</span><span class="p">,</span><span class="w"> </span><span class="n">phenotype_info</span><span class="o">=</span><span class="n">pData</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">)[</span><span class="n">colnames</span><span class="p">(</span><span class="n">mat</span><span class="p">),],</span><span class="w">
                          </span><span class="n">feature_info</span><span class="o">=</span><span class="n">fData</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">)[</span><span class="n">rownames</span><span class="p">(</span><span class="n">mat</span><span class="p">),],</span><span class="w">
                          </span><span class="n">annotation_info</span><span class="o">=</span><span class="n">annotation</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">))</span><span class="w">
</span><span class="c1"># Updata network.par with new eset</span><span class="w">
</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">net_eset</span><span class="w">
</span><span class="c1"># QC for the normalized eset</span><span class="w">
</span><span class="n">draw.eset.QC</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">,</span><span class="n">outdir</span><span class="o">=</span><span class="n">network.par</span><span class="o">$</span><span class="n">out.dir.QC</span><span class="p">,</span><span class="n">intgroup</span><span class="o">=</span><span class="kc">NULL</span><span class="p">,</span><span class="n">do.logtransform</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="s1">'afterQC_'</span><span class="p">,</span><span class="w">
             </span><span class="n">pre_define</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s1">'WNT'</span><span class="o">=</span><span class="s1">'blue'</span><span class="p">,</span><span class="s1">'SHH'</span><span class="o">=</span><span class="s1">'red'</span><span class="p">,</span><span class="s1">'G4'</span><span class="o">=</span><span class="s1">'green'</span><span class="p">),</span><span class="n">emb_plot_type</span><span class="o">=</span><span class="s1">'2D.interactive'</span><span class="p">)</span><span class="w">
</span><span class="c1"># Save Step 2 network.par as RData</span><span class="w">
</span><span class="n">NetBID.saveRData</span><span class="p">(</span><span class="n">network.par</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">network.par</span><span class="p">,</span><span class="n">step</span><span class="o">=</span><span class="s1">'exp-QC'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>- What information can you get from the HTML QC report after QC steps?</strong> (<a href="afterQC_QC.html">after_QC.html</a>)</p>
<ul>
  <li>A table. Compare the table with the one in Step 1. To see if a large amount of genes/samples has been removed;</li>
  <li>A heatmap and a PCA/MDS/UMAP biplot. All samples will be clustered using the normalized expression values across all the genes as features. The aim of this is to check possible mis-labeled samples;</li>
  <li>A correlation plot for all sample pairs. This helps to check the correlation within group and between groups.</li>
  <li>A density plot. Compare the table with the one in Step 1. To see if the low expressed genes have been removed;</li>
</ul>

<hr />
<h3 id="qc-for-rna-seq-dataset"><em>QC for RNA-Seq dataset</em></h3>
<ul>
  <li>QC Step 1 to Step 3 are not suitable for RNA-Seq dataset, regardless of their pre-processing strategies. Only QC Step 4, “removing low expressed genes” is suggested to perform.
For example, if one uses <code class="highlighter-rouge">load.exp.RNASeq.demo()</code> or <code class="highlighter-rouge">load.exp.RNASeq.demoSalmon()</code> with settings of <code class="highlighter-rouge">dds</code> or <code class="highlighter-rouge">eset</code>. There is no need for normalization.</li>
  <li>If one uses the raw count data as the expression matrix, he can call <code class="highlighter-rouge">RNASeqCount.normalize.scale()</code> to perform normalizaiton, which is followed by “log2 transformation”.</li>
  <li>If one uses the FPKM (Fagments Per Kilobase Million), TPM (Transcripts Per Million), CPM (Counts Per Million), the “log2 transformation” from QC Step 2 is suggested.</li>
  <li>The quality control analysis is different from case to case, NetBID2 only provides functions and tools to faciliate users to make their own decisions. Following the calling softwares’ pipeline is strongly suggested.</li>
</ul>

<hr />
<h3 id="combine-two-datasets"><em>Combine two datasets</em></h3>
<ul>
  <li>To combine two expression datasets, please call <code class="highlighter-rouge">merge_eset()</code>.</li>
  <li>If the two expression datasets come from the same platform and contain the same gene list, no Z-transformation will be performed. 
Otherwise, Z-transformation is suggested to be performed before combining these two datasets.</li>
  <li>The merged ExpressionSet class object will include a new phenotype column set by <code class="highlighter-rouge">group_col_name</code>, this column is used to distinguish each sample’s original dataset.</li>
  <li>No batch effect will be removed during combination by default. It is strongly suggested to check the sample clustering results before trying to remove the batch (User could follow the pipeline in the following Step 3). Generally, batch effect exists for microarray dataset but not for RNA-Seq dataset with the same protocal.</li>
</ul>

<hr />

<h2 id="step-3-check-sample-cluster-analysis-optional-exp-cluster">Step 3: Check sample cluster analysis, optional (exp-cluster)</h2>
<p><strong>Purpose: check if the highly variable genes can be used to perform good sample cluster analysis (predicted labels vs. real labels).</strong>
This step is not necessary to perform NetBID2. Just create plots for visualization, no modification to the data.</p>

<p>Please skip the following line if you didn’t close R session after completed Step 1 and Step 2.</p>

<p>Don’t skip, if you have checked out and closed R session after completed the Step 1 and Step 2. Before start Step 3, please reload <code class="highlighter-rouge">network.par</code> RData from Step 2.
<code class="highlighter-rouge">NetBID.loadRData()</code> reloads RData saved by <code class="highlighter-rouge">NetBID.saveRData()</code>. It prevents user from repeating former pipeline steps.
If the re-opened R session doesn’t have <code class="highlighter-rouge">network.par</code> in the environment, please comment off the first two command lines. It will create a temporary <code class="highlighter-rouge">network.par</code>
with path of the saved Step 1 RData, <code class="highlighter-rouge">network.par$out.dir.DATA</code>. The path <code class="highlighter-rouge">test//project_2019-05-02//DATA/</code> here is just an example, 
users need to give their own path used to save <code class="highlighter-rouge">network.par</code> RData from Step 2.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Reload network.par RData from Step 2</span><span class="w">
</span><span class="c1">#network.par &lt;- list()</span><span class="w">
</span><span class="c1">#network.par$out.dir.DATA &lt;- 'test//project_2019-05-02//DATA/'</span><span class="w">
</span><span class="n">NetBID.loadRData</span><span class="p">(</span><span class="n">network.par</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">network.par</span><span class="p">,</span><span class="n">step</span><span class="o">=</span><span class="s1">'exp-QC'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>Select the most variable genes across samples using <code class="highlighter-rouge">IQR.filter()</code> to perform sample cluster analysis.</strong>
IQR (interquartile range) is a measure of statistical dispersion. It is calculated for each gene across all the samples. 
<code class="highlighter-rouge">IQR.filter</code> extract top 50% variable genes from the expression matrix by setting <code class="highlighter-rouge">thre</code> to 0.5. 
Users can also set a list of interested genes <code class="highlighter-rouge">loose_gene</code> to pass a less stringent filter, by setting a looser threshold value to <code class="highlighter-rouge">loose_thre</code>.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Select the most variable genes across samples</span><span class="w">
</span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">exprs</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">)</span><span class="w">
</span><span class="n">choose1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">IQR.filter</span><span class="p">(</span><span class="n">exp_mat</span><span class="o">=</span><span class="n">mat</span><span class="p">,</span><span class="n">use_genes</span><span class="o">=</span><span class="n">rownames</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span><span class="n">thre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5</span><span class="p">)</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">table</span><span class="p">(</span><span class="n">choose1</span><span class="p">))</span><span class="w">
</span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mat</span><span class="p">[</span><span class="n">choose1</span><span class="p">,]</span><span class="w">
</span></code></pre></div></div>

<p><strong>To have a taste of how IQR filtered genes will affect the cluster analysis of samples.</strong>
Wrap the filtered genes into a temporary ExpressionSet object and create a HTML QC report. <a href="Cluster_QC.html">Cluster_QC.html</a></p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Generate temporary eset</span><span class="w">
</span><span class="n">tmp_net_eset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">generate.eset</span><span class="p">(</span><span class="n">exp_mat</span><span class="o">=</span><span class="n">mat</span><span class="p">,</span><span class="w"> </span><span class="n">phenotype_info</span><span class="o">=</span><span class="n">pData</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">)[</span><span class="n">colnames</span><span class="p">(</span><span class="n">mat</span><span class="p">),],</span><span class="w">
                          </span><span class="n">feature_info</span><span class="o">=</span><span class="n">fData</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">)[</span><span class="n">rownames</span><span class="p">(</span><span class="n">mat</span><span class="p">),],</span><span class="w"> </span><span class="n">annotation_info</span><span class="o">=</span><span class="n">annotation</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">))</span><span class="w">
</span><span class="c1"># QC plot for IQR filtered eset</span><span class="w">
</span><span class="n">draw.eset.QC</span><span class="p">(</span><span class="n">tmp_net_eset</span><span class="p">,</span><span class="n">outdir</span><span class="o">=</span><span class="n">network.par</span><span class="o">$</span><span class="n">out.dir.QC</span><span class="p">,</span><span class="n">intgroup</span><span class="o">=</span><span class="kc">NULL</span><span class="p">,</span><span class="n">do.logtransform</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="s1">'Cluster_'</span><span class="p">,</span><span class="w">
             </span><span class="n">pre_define</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s1">'WNT'</span><span class="o">=</span><span class="s1">'blue'</span><span class="p">,</span><span class="s1">'SHH'</span><span class="o">=</span><span class="s1">'red'</span><span class="p">,</span><span class="s1">'G4'</span><span class="o">=</span><span class="s1">'green'</span><span class="p">),</span><span class="n">emb_plot_type</span><span class="o">=</span><span class="s1">'2D.interactive'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The following scripts provide various ways to visualize and check if the IQR filter selected genes can be used to perform good sample cluster analysis (observed labels vs. predicted labels). 
Figures will be displayed instead of saving as files.</p>

<p><strong>First, extract “cluster-meaningful” phenotype columns.</strong></p>

<p>Each column of the phenotype information data frame <code class="highlighter-rouge">pData(network.par$net.eset)</code> can contain certain categories.
For example, the “gender” column in the phenotype data frame, it has two categories, “Male” and “Female”. This categorial information gives the observed labels to samples.
If users don’t know which phenotype columns to extract, <code class="highlighter-rouge">get_int_group</code> will extract all “cluster-meaningful” phenotype columns from the ExpressionSet object.
For example, if “gender” column only contains “Female”, it is meaningless to extract is to do cluster analysis, cause all samples will be clustered as one.
Another example, if all samples have differnet age, it is meaningless to extract “age” column, cause all samples will be grouped separately.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Extract phenotype information data frame from eset</span><span class="w">
</span><span class="n">phe</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">pData</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">)</span><span class="w">
</span><span class="c1"># Extract all "cluster-meaningful" phenotype columns</span><span class="w">
</span><span class="n">intgroup</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_int_group</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>Second, perform clustering analysis on all “cluster-meaningful” phenotype columns and draw plots.</strong>
for each phenotype column in the <code class="highlighter-rouge">intgroup</code>, user can choose <code class="highlighter-rouge">embedding_method</code> from ‘pca’,’mds’ and ‘umap’ in <code class="highlighter-rouge">draw.emb.kmeans()</code> to cluster samples and visualize the result between the observed label vs. the predicted label. The clustering is performed by K-means, and the result can be plotted using PCA/MDS biplot or UMAP (Uniform Manifold Approximation and Projection). 
User can also choose another clustering method, <a href="https://github.com/jyyulab/scMINER/tree/master/MICA">MICA</a>, by calling <code class="highlighter-rouge">draw.MICA()</code>. 
All three functions can either return the K-value yielding the optimal result (setting <code class="highlighter-rouge">return_type='optimal'</code>), or all the K-values (setting <code class="highlighter-rouge">return_type='all'</code>) used for clustering.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Cluster analysis using Kmeans and plot result using PCA biplot (pca+kmeans in 2D)</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">intgroup</span><span class="p">)){</span><span class="w">
  </span><span class="n">print</span><span class="p">(</span><span class="n">intgroup</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w">
  </span><span class="n">pred_label</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">draw.emb.kmeans</span><span class="p">(</span><span class="n">mat</span><span class="o">=</span><span class="n">mat</span><span class="p">,</span><span class="n">all_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="n">obs_label</span><span class="o">=</span><span class="n">get_obs_label</span><span class="p">(</span><span class="n">phe</span><span class="p">,</span><span class="n">intgroup</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="n">pre_define</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s1">'WNT'</span><span class="o">=</span><span class="s1">'blue'</span><span class="p">,</span><span class="s1">'SHH'</span><span class="o">=</span><span class="s1">'red'</span><span class="p">,</span><span class="s1">'G4'</span><span class="o">=</span><span class="s1">'green'</span><span class="p">))</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Here, we pick the <code class="highlighter-rouge">subgroup</code> column from the demo’s phenotype data frame as an example, to show various visualization tools NetBID2 can provide.</strong>
<code class="highlighter-rouge">get_obs_label()</code> returns a vector of selected phenotype descriptive information for each sample.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">use_int</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s1">'subgroup'</span><span class="w">
</span><span class="n">pred_label</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">draw.emb.kmeans</span><span class="p">(</span><span class="n">mat</span><span class="o">=</span><span class="n">mat</span><span class="p">,</span><span class="n">all_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="n">obs_label</span><span class="o">=</span><span class="n">get_obs_label</span><span class="p">(</span><span class="n">phe</span><span class="p">,</span><span class="n">use_int</span><span class="p">),</span><span class="n">plot_type</span><span class="o">=</span><span class="s1">'2D'</span><span class="p">,</span><span class="n">pre_define</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s1">'WNT'</span><span class="o">=</span><span class="s1">'blue'</span><span class="p">,</span><span class="s1">'SHH'</span><span class="o">=</span><span class="s1">'red'</span><span class="p">,</span><span class="s1">'G4'</span><span class="o">=</span><span class="s1">'green'</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p><img src="sample_cluster_1.png" alt="sample_cluster_1" /></p>

<p>Above is a side-by-side basic scatter plot of samples. The categories of observed labels (left figure) and predicted labels (right figure) are distinguished by color.
The calculated statistics on top of the right figure quantifies the similarity between observed labels predicted labels. 
ARI is short for “adjusted rand index”, ranges from 0 to 1. Higher ARI value indicates higher similarity. For details, please check <code class="highlighter-rouge">get_clustComp()</code>.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pred_label</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">draw.emb.kmeans</span><span class="p">(</span><span class="n">mat</span><span class="o">=</span><span class="n">mat</span><span class="p">,</span><span class="n">all_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="n">obs_label</span><span class="o">=</span><span class="n">get_obs_label</span><span class="p">(</span><span class="n">phe</span><span class="p">,</span><span class="n">use_int</span><span class="p">),</span><span class="n">plot_type</span><span class="o">=</span><span class="s1">'2D.ellipse'</span><span class="p">,</span><span class="n">pre_define</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s1">'WNT'</span><span class="o">=</span><span class="s1">'blue'</span><span class="p">,</span><span class="s1">'SHH'</span><span class="o">=</span><span class="s1">'red'</span><span class="p">,</span><span class="s1">'G4'</span><span class="o">=</span><span class="s1">'green'</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p><img src="sample_cluster_2.png" alt="sample_cluster_2" /></p>

<p>Above is a side-by-side scatter plot with an ellipse drawn around each cluster of samples. Each ellipse is marked with its cluster label.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pred_label</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">draw.emb.kmeans</span><span class="p">(</span><span class="n">mat</span><span class="o">=</span><span class="n">mat</span><span class="p">,</span><span class="n">all_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="n">obs_label</span><span class="o">=</span><span class="n">get_obs_label</span><span class="p">(</span><span class="n">phe</span><span class="p">,</span><span class="n">use_int</span><span class="p">),</span><span class="n">plot_type</span><span class="o">=</span><span class="s1">'3D'</span><span class="p">,</span><span class="n">pre_define</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s1">'WNT'</span><span class="o">=</span><span class="s1">'blue'</span><span class="p">,</span><span class="s1">'SHH'</span><span class="o">=</span><span class="s1">'red'</span><span class="p">,</span><span class="s1">'G4'</span><span class="o">=</span><span class="s1">'green'</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p><img src="sample_cluster_4.png" alt="sample_cluster_4" /></p>

<p>Above is a side-by-side scatter plot in 3D. Here, we use the first three principle component as axises.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">print</span><span class="p">(</span><span class="n">table</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">pred_label</span><span class="o">=</span><span class="n">pred_label</span><span class="p">,</span><span class="n">obs_label</span><span class="o">=</span><span class="n">get_obs_label</span><span class="p">(</span><span class="n">phe</span><span class="p">,</span><span class="w"> </span><span class="n">use_int</span><span class="p">))))</span><span class="w">
</span><span class="n">draw.clustComp</span><span class="p">(</span><span class="n">pred_label</span><span class="p">,</span><span class="n">obs_label</span><span class="o">=</span><span class="n">get_obs_label</span><span class="p">(</span><span class="n">phe</span><span class="p">,</span><span class="n">use_int</span><span class="p">),</span><span class="n">outlier_cex</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="n">low_K</span><span class="o">=</span><span class="m">10</span><span class="p">)</span><span class="w"> 
</span></code></pre></div></div>

<p><img src="sample_cluster_5.png" alt="sample_cluster_4" /></p>

<p>Above is a table to visualize each sample’s observed label vs. its predicted label, it shows more details. 
The darker the table cell is, the more samples are gathered in the corresponding label. We can see 4 WNTs can be further separated into two sub-groups.
However, in this demo dataset, no obvious outlier samples are observed.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">draw.emb.kmeans</span><span class="p">(</span><span class="n">mat</span><span class="o">=</span><span class="n">mat</span><span class="p">,</span><span class="n">all_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="n">obs_label</span><span class="o">=</span><span class="n">get_obs_label</span><span class="p">(</span><span class="n">phe</span><span class="p">,</span><span class="n">use_int</span><span class="p">),</span><span class="w">
                </span><span class="n">plot_type</span><span class="o">=</span><span class="s1">'2D.interactive'</span><span class="p">,</span><span class="w">
                </span><span class="n">pre_define</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s1">'WNT'</span><span class="o">=</span><span class="s1">'blue'</span><span class="p">,</span><span class="s1">'SHH'</span><span class="o">=</span><span class="s1">'red'</span><span class="p">,</span><span class="s1">'G4'</span><span class="o">=</span><span class="s1">'green'</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<iframe width="600" height="400" frameborder="0" scrolling="no" src="https://jyyulab.github.io/NetBID/docs/network_reconstruction/interactive.html"></iframe>

<p>Above is the interactive plot, user could mouse over to check the sample label for each points.
The text for each point is organized as “sample_name:observed_label:predicted_label”.
The color to the points are categorized by the observed label and the shape by the predicted label.</p>

<p>If user found an outlier sample and removed it, we suggest to re-run Step 2 and Step 3 to see whether the data got cleaner after the remove of outlier.</p>

<h2 id="step-4-prepare-files-to-run-sjaracne-sjaracne-prep">Step 4: Prepare files to run SJARACNe (sjaracne-prep)</h2>
<p><strong>Purpose: download SJARACNe needed database to local folders and prepare files to run SJARACNe.</strong></p>

<p>Please skip the following line if you didn’t close R session after completed Step 1 and Step 2 (doesn’t matter if you runned Step 3 or not).</p>

<p>Don’t skip, if you have checked out and closed R session after completed the Step 1 and Step 2. Before start Step 4, please reload <code class="highlighter-rouge">network.par</code> RData from Step 2.
<code class="highlighter-rouge">NetBID.loadRData()</code> reloads RData saved by <code class="highlighter-rouge">NetBID.saveRData()</code>. It prevents user from repeating former pipeline steps.
If the re-opened R session doesn’t have <code class="highlighter-rouge">network.par</code> in the environment, please comment off the first two command lines. It will create a temporary <code class="highlighter-rouge">network.par</code>
with path of the saved Step 1 RData, <code class="highlighter-rouge">network.par$out.dir.DATA</code>. The path <code class="highlighter-rouge">test//project_2019-05-02//DATA/</code> here is just an example, 
users need to give their own path used to save <code class="highlighter-rouge">network.par</code> RData from Step 2.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Reload network.par RData from Step 2</span><span class="w">
</span><span class="c1">#network.par &lt;- list()</span><span class="w">
</span><span class="c1">#network.par$out.dir.DATA &lt;- 'test//project_2019-05-02//DATA/'</span><span class="w">
</span><span class="n">NetBID.loadRData</span><span class="p">(</span><span class="n">network.par</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">network.par</span><span class="p">,</span><span class="n">step</span><span class="o">=</span><span class="s1">'exp-QC'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>First, use <code class="highlighter-rouge">db.preload()</code> to download the transcription facotrs (TF) list and signaling factors (SIG) list, with species and level defined.</strong></p>

<p>For the TF and SIG list, NetBID2 has <code class="highlighter-rouge">external_gene_name</code> and <code class="highlighter-rouge">ensembl_gene_id</code> ID type files for human and mouse embedded in the package. (e.g. <code class="highlighter-rouge">MOUSE_SIG_ensembl_gene_id.txt</code> in <code class="highlighter-rouge">system.file(package = "NetBID2")/db/</code>). To use these files, just set <code class="highlighter-rouge">TF_list=NULL</code> or <code class="highlighter-rouge">SIG_list=NULL</code>. If users would like to use their own list, please pass them to <code class="highlighter-rouge">TF_list=NULL</code> or <code class="highlighter-rouge">SIG_list=NULL</code>.</p>

<p>For the species and level, NetBID2 has prepared both “gene-level”” and “transcript-level” RData for human by default. If the target species is not human, user can set <code class="highlighter-rouge">use_spe</code> to target species, and <code class="highlighter-rouge">db.preload()</code> will prepare that species database.</p>

<p>For the storage of downloaded data, if user leaves <code class="highlighter-rouge">main.dir=NULL</code>, the RData will be saved automatically to <code class="highlighter-rouge">system.file(package = "NetBID2")/db/</code>. 
If NetBID2 is installed in a public place and user doesn’t have the root permissions, one can set <code class="highlighter-rouge">main.dir</code> to another path with permission. 
And please make sure to use the same path for the further analysis.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Load database</span><span class="w">
</span><span class="n">db.preload</span><span class="p">(</span><span class="n">use_level</span><span class="o">=</span><span class="s1">'gene'</span><span class="p">,</span><span class="n">use_spe</span><span class="o">=</span><span class="s1">'human'</span><span class="p">,</span><span class="n">update</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>Second, converts gene ID into the corresponding TF/SIG list, with selected gene/transcript type.</strong>
Users can set <code class="highlighter-rouge">use_gene_type</code> in the function <code class="highlighter-rouge">get.TF_SIG.list()</code> to pick the attribute name to convert to.
Options are, “ensembl_gene_id”, “ensembl_gene_id_version”, “ensembl_transcript_id”, “ensembl_transcript_id_version” and “refseq_mrna”.
For details, please check <a href="#id-conversion"><strong><em>ID conversion</em></strong></a> section below.
Conversion is <em>not required</em>, if user can get the <code class="highlighter-rouge">TF_list</code> and <code class="highlighter-rouge">SIG_list</code> with the same ID type as in the expression matrix. 
In this case, users can jump to the final step to call <code class="highlighter-rouge">SJAracne.prepare()</code>.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Converts gene ID into the corresponding TF/SIG list</span><span class="w">
</span><span class="n">use_gene_type</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s1">'external_gene_name'</span><span class="w"> </span><span class="c1"># user-defined</span><span class="w">
</span><span class="n">use_genes</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">fData</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">))</span><span class="w">
</span><span class="n">use_list</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get.TF_SIG.list</span><span class="p">(</span><span class="n">use_genes</span><span class="p">,</span><span class="n">use_gene_type</span><span class="o">=</span><span class="n">use_gene_type</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><strong>Last, use <code class="highlighter-rouge">SJAracne.prepare()</code> to prepare files for running SJARACNe.</strong></p>

<p>For sample selection: user can choose to use all the samples or some of them. Here we use all the samples.
For creating multiple networks: user can set <code class="highlighter-rouge">prj.name</code> for easier reference. For example, if user wants to create Group4 specific network using Group4 samples. Just specify <code class="highlighter-rouge">use.samples</code> 
and <code class="highlighter-rouge">prj.name = 'Group4_net'</code>. This <code class="highlighter-rouge">prj.name</code> setting is important for the <a href="../driver_inference">Driver inference</a> part. 
For other parameters: the <code class="highlighter-rouge">IQR.thre</code> and <code class="highlighter-rouge">IQR.loose_thre</code> will be passed to <code class="highlighter-rouge">IQR.filter()</code>. The <code class="highlighter-rouge">loose_gene</code> will be the genes in <code class="highlighter-rouge">TF_list</code> and <code class="highlighter-rouge">SIG_list</code>, which pre-defined as the possible drivers during network reconstruction.
For output file size: here in the demo, in order to control the file size, we set <code class="highlighter-rouge">IQR.thre=0.9</code> and <code class="highlighter-rouge">IQR.loose_thre=0.7</code>. However, in real practice, <code class="highlighter-rouge">IQR.thre=0.5</code> and <code class="highlighter-rouge">IQR.loose_thre=0.1</code> is recommended.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Select samples for analysis</span><span class="w">
</span><span class="n">phe</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">pData</span><span class="p">(</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">)</span><span class="w">
</span><span class="n">use.samples</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">phe</span><span class="p">)</span><span class="w"> </span><span class="c1"># here is using all samples, users can modify</span><span class="w">
</span><span class="n">prj.name</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">network.par</span><span class="o">$</span><span class="n">project.name</span><span class="w"> </span><span class="c1"># if use different samples, need to change the project name</span><span class="w">
</span><span class="n">SJAracne.prepare</span><span class="p">(</span><span class="n">eset</span><span class="o">=</span><span class="n">network.par</span><span class="o">$</span><span class="n">net.eset</span><span class="p">,</span><span class="n">use.samples</span><span class="o">=</span><span class="n">use.samples</span><span class="p">,</span><span class="w">
                    </span><span class="n">TF_list</span><span class="o">=</span><span class="n">use_list</span><span class="o">$</span><span class="n">tf</span><span class="p">,</span><span class="n">SIG_list</span><span class="o">=</span><span class="n">use_list</span><span class="o">$</span><span class="n">sig</span><span class="p">,</span><span class="w">
                    </span><span class="n">IQR.thre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5</span><span class="p">,</span><span class="n">IQR.loose_thre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.1</span><span class="p">,</span><span class="w">
                    </span><span class="n">SJAR.project_name</span><span class="o">=</span><span class="n">prj.name</span><span class="p">,</span><span class="n">SJAR.main_dir</span><span class="o">=</span><span class="n">network.par</span><span class="o">$</span><span class="n">out.dir.SJAR</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Due to the memory consumption and speed computational capability, SJARACNe will handle the network reconstruction, please follow the github tutorial to run <a href="https://github.com/jyyulab/SJARACNe">SJARACNe</a>.</p>

<hr />
<h3 id="id-conversion"><em>ID conversion</em></h3>

<p>We use the ID conversion tools from <a href="https://bioconductor.org/packages/release/bioc/vignettes/biomaRt/inst/doc/biomaRt.html">biomaRt</a>.
The ID names with different types (e.g gene symbols) or ID related attributes (e.g gene biotype) in biomaRt package, are the values we are interested in to retrieve.
The commonly used ID types are “external_gene_name”,”ensembl_gene_id”, “ensembl_gene_id_version”, “ensembl_transcript_id”, “ensembl_transcript_id_version” and “refseq_mrna”. 
The listAttributes() function displays all available attributes in the selected dataset.</p>

<p><strong>ATTENTION</strong></p>
<ul>
  <li>biomaRt will use the newest version number of <a href="https://www.gencodegenes.org">GENCODE</a>. Since all the ID conversion related functions <code class="highlighter-rouge">db.preload()</code>, <code class="highlighter-rouge">get.TF_SIG.list()</code>, <code class="highlighter-rouge">get_IDtransfer()</code>, <code class="highlighter-rouge">get_IDtransfer2symbol2type()</code> and <code class="highlighter-rouge">get_IDtransfer_betweenSpecies()</code> will access the archived database through website link, the version number of ensembl ID may vary from different runs. Users can set <code class="highlighter-rouge">ignore_version=TRUE</code> to ignore the version number for ensembl IDs.</li>
  <li>Functions like, <code class="highlighter-rouge">get_IDtransfer()</code>, <code class="highlighter-rouge">get_IDtransfer2symbol2type()</code> and <code class="highlighter-rouge">get_IDtransfer_betweenSpecies()</code> can generate the conversion table for <code class="highlighter-rouge">get_name_transfertab()</code>. 
However, users can choose to use their own curated one.</li>
</ul>
:ET